from pwn import *
import os, subprocess, re, sys

class AEG:
	def __init__(self, filepath):
		self.file = filepath
		self.bin = ELF(filepath)
		self.rop = ROP(self.bin)
		self.funcs = self.bin.sym.keys()

	def analyze_funcs(self):
		print('ANALYZING FUNCTIONS...')
		# Check for tell of a ROP problem - presence of a symbol named gadget
		self.has_gadget = False
		self.has_printf = False
		self.can_overflow = False
		self.can_leak = False
		#self.has_win = False
		for f in self.funcs:
			srch = re.search(r"gadget", f)
			if srch != None:
				print('Found a hardcoded gadget:', f)
				self.has_gadget = True
			if f == 'printf':
				print('Found a call to printf:', f)
				self.has_printf = True
			if f == 'gets':
				#print('Found a win() function:', f)
				self.can_overflow = True

	# Look at Input/Output 
	def analyze_IO(self):
		p = process(self.file)
		self.num_inputs = 0
		self.input_exploits = dict()
		# This will find number of inputs, and look for any printf leaks
		while(p.poll() == None):
			if p.can_recv(timeout=1):
				try:
					line = p.recv().decode()
				except EOFError:
					continue
				srch = re.search(r'0x[0-9a-f]+', line)
				if srch != None:
					print(f'Leak Found!: {line}')
					self.can_leak = True
					i = self.num_inputs
					# Record that this input can be attacked with print format bug
					if i in self.input_exploits.keys():
						self.input_exploits[i].append('leak')
					else:
						self.input_exploits[i] = ['leak']
						
				
			else:
				self.num_inputs += 1
				if self.has_printf:
					p.sendline('%p %p %p')
				else:
					p.sendline('a')
		
		#print(self.input_exploits)

		# Now check for buffer overflows on each input
		for i in range(self.num_inputs):
			p.close()
			p.kill()
			p = process(self.file)
			curr_input = 0
			checked_input = False
			while p.poll() == None and checked_input==False:
				
				if p.can_recv(timeout=1):
					try:
						p.recv()
					except EOFError:
						continue
				else:
					# Only test one input at a time
					if curr_input != i:
						p.sendline('a')
						curr_input += 1
					else:
						checked_input = True
						# Send in cyclic pattern and check for overflow
						p.sendline(cyclic(1024, n=8))
						p.wait()
						core = p.corefile
						p.close()
						if core == None:	# No core dump means no overflow
							continue
						os.remove(core.file.name)
						padding = cyclic_find(core.read(core.rsp, 8), n=8)
						if padding == -0x1:
							# If rsp didn't give us the overflow for whatever reason, check rbp
							padding = cyclic_find(core.read(core.rbp, 8), n=8) # + 8
							# If padding is still -0x1, then there is no overflow on this input
							if padding == -0x1:
								continue
							else:
								padding += 8	# add 8 to increment from rbp to return address
						# If we reach here, we found an overflow
						j = i+1
						if j in self.input_exploits.keys():
							self.input_exploits[j].append(f'overflow:{padding}')
						else:
							self.input_exploits[j] = [f'overflow:{padding}']
		#print(self.input_exploits)
		p.close()
		p.kill()				

		


	def get_analysis(self):
		print(f'ROP: {self.has_gadget}')
		print(f'String format bug: {self.has_printf}')
		print(f'Number of inputs: {self.num_inputs}')
		print(f'Input Attack Vectors: {self.input_exploits}')
		#print(f'Ret2Win exploit: {self.is_ret2win}')
try:
	solver = AEG(args.BIN)

except FileNotFoundError:
	print("FileNotFoundError")
	print('Pass in a binary to exploit: python3 solarpanth3r.py BIN=<binary>')
	sys.exit()

solver.analyze_funcs()
solver.analyze_IO()
solver.get_analysis()
